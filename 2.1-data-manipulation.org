* Data Manipulation

** Getting Started

#+begin_src clojure :results silent
(ns clj-d2l.priliminaries
  (:require [clj-djl.ndarray :as nd]
            [clj-d2l.utils :refer [pp]])
  (:import [ai.djl.ndarray.types DataType]))
#+end_src

Create a vector from in range 0 - 11:

#+begin_src clojure :results output :exports both
(def ndm (nd/new-base-manager))
(pp ndm)
#+end_src

#+RESULTS:
: UID: 0b26759d-e9ed-4289-89cc-46e9de92e28c Parent UID: 3661c86c-2636-4d1f-827e-9c3092443bc5 isOpen: true Resource size: 0

#+begin_src clojure :results output :exports both
(def x (nd/arange ndm 0 12))
(pp x)
#+end_src

#+RESULTS:
: ND: (12) cpu() int32
: [ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11]

#+begin_src clojure :exports both
(nd/get-shape x)
(nd/size x)
#+end_src

#+RESULTS:
: #object[ai.djl.ndarray.types.Shape 0x9ad8589 "(12)"]
: 12

#+begin_src clojure :results output :exports both
(def y (nd/reshape x [3 4]))
(pp y)
#+end_src

#+RESULTS:
: ND: (3, 4) cpu() int32
: [[ 0,  1,  2,  3],
:  [ 4,  5,  6,  7],
:  [ 8,  9, 10, 11],
: ]


automatically inference the rest dimention specified with =-1=:

#+begin_src clojure :results output :exports both
(def y (nd/reshape x [3 -1]))
(pp y)
#+end_src

#+RESULTS:
: ND: (3, 4) cpu() int32
: [[ 0,  1,  2,  3],
:  [ 4,  5,  6,  7],
:  [ 8,  9, 10, 11],
: ]


#+begin_src clojure :results output :exports both
(println (nd/shape 2 3))
#+end_src

#+RESULTS:
: #object[ai.djl.ndarray.types.Shape 0x5760ba5a (2, 3)]

#+begin_src clojure :results output :exports both
(println (nd/create ndm (int-array [2 3])))
#+end_src

#+RESULTS:
: #object[ai.djl.mxnet.engine.MxNDArray 0x2df4c9f4 ND: (2) cpu() int32
: [ 2,  3]
: ]

#+begin_src clojure :results output :exports both
(pp (nd/zeros ndm 2 3))
(pp (nd/zeros ndm 2 3 4))
(pp (nd/zeros ndm 2 2 2 2))
(pp (nd/zeros ndm [2 3]))
(pp (nd/zeros ndm [2 3 4]))
(pp (nd/zeros ndm [2 2 2 2]))
#+end_src

#+RESULTS:
#+begin_example
ND: (2, 3) cpu() float32
[[0., 0., 0.],
 [0., 0., 0.],
]
ND: (2, 3, 4) cpu() float32
[[[0., 0., 0., 0.],
  [0., 0., 0., 0.],
  [0., 0., 0., 0.],
 ],
 [[0., 0., 0., 0.],
  [0., 0., 0., 0.],
  [0., 0., 0., 0.],
 ],
]
ND: (2, 2, 2, 2) cpu() float32
[[[[0., 0.],
   [0., 0.],
  ],
  [[0., 0.],
   [0., 0.],
  ],
 ],
 [[[0., 0.],
   [0., 0.],
  ],
  [[0., 0.],
   [0., 0.],
  ],
 ],
]
ND: (2, 3) cpu() float32
[[0., 0., 0.],
 [0., 0., 0.],
]
ND: (2, 3, 4) cpu() float32
[[[0., 0., 0., 0.],
  [0., 0., 0., 0.],
  [0., 0., 0., 0.],
 ],
 [[0., 0., 0., 0.],
  [0., 0., 0., 0.],
  [0., 0., 0., 0.],
 ],
]
ND: (2, 2, 2, 2) cpu() float32
[[[[0., 0.],
   [0., 0.],
  ],
  [[0., 0.],
   [0., 0.],
  ],
 ],
 [[[0., 0.],
   [0., 0.],
  ],
  [[0., 0.],
   [0., 0.],
  ],
 ],
]
#+end_example

#+begin_src clojure :results output :exports both
(pp (nd/ones ndm 2 3))
(pp (nd/ones ndm 2 3 4))
(pp (nd/ones ndm 2 2 2 2))
(pp (nd/ones ndm [2 3]))
(pp (nd/ones ndm [2 3 4]))
(pp (nd/ones ndm [2 2 2 2]))
#+end_src

#+RESULTS:
#+begin_example
ND: (2, 3) cpu() float32
[[1., 1., 1.],
 [1., 1., 1.],
]
ND: (2, 3, 4) cpu() float32
[[[1., 1., 1., 1.],
  [1., 1., 1., 1.],
  [1., 1., 1., 1.],
 ],
 [[1., 1., 1., 1.],
  [1., 1., 1., 1.],
  [1., 1., 1., 1.],
 ],
]
ND: (2, 2, 2, 2) cpu() float32
[[[[1., 1.],
   [1., 1.],
  ],
  [[1., 1.],
   [1., 1.],
  ],
 ],
 [[[1., 1.],
   [1., 1.],
  ],
  [[1., 1.],
   [1., 1.],
  ],
 ],
]
ND: (2, 3) cpu() float32
[[1., 1., 1.],
 [1., 1., 1.],
]
ND: (2, 3, 4) cpu() float32
[[[1., 1., 1., 1.],
  [1., 1., 1., 1.],
  [1., 1., 1., 1.],
 ],
 [[1., 1., 1., 1.],
  [1., 1., 1., 1.],
  [1., 1., 1., 1.],
 ],
]
ND: (2, 2, 2, 2) cpu() float32
[[[[1., 1.],
   [1., 1.],
  ],
  [[1., 1.],
   [1., 1.],
  ],
 ],
 [[[1., 1.],
   [1., 1.],
  ],
  [[1., 1.],
   [1., 1.],
  ],
 ],
]
#+end_example


#+begin_src clojure :results output :exports both
(pp (nd/random-normal 0 1 [3 4] DataType/FLOAT32))
#+end_src

#+RESULTS:
: ND: (3, 4) cpu() float32
: [[ 2.2122,  1.1631,  0.774 ,  0.4838],
:  [ 1.0434,  0.2996,  1.1839,  0.153 ],
:  [ 1.8917, -1.1688, -1.2347,  1.5581],
: ]

#+begin_src clojure :results output :exports both
(pp (nd/random-normal [3 4]))
#+end_src

#+RESULTS:
: ND: (3, 4) cpu() float32
: [[ 0.2444, -0.6811, -0.0372, -0.1353],
:  [-0.4877,  0.3772, -0.0226,  0.4102],
:  [ 0.5746,  0.5713,  1.4661, -2.758 ],
: ]

** Operations

#+begin_src clojure :results output :exports both
(pp (nd/create ndm (int-array [2 1 4 3]) (nd/shape [2 2])))
#+end_src

#+RESULTS:
: ND: (2, 2) cpu() int32
: [[ 2,  1],
:  [ 4,  3],
: ]

#+begin_src clojure :results output :exports both
;;(println (str (nd/->ndarray [[2 1 4 3] [1 2 3 4] [4 3 2 1]])))
#+end_src

#+RESULTS:

#+begin_src clojure :results output :exports both
(def x (nd/create ndm (int-array [1 2 4 8]) (nd/shape [2 2])))
(def y (nd/create ndm (int-array [2 2 2 2]) (nd/shape [2 2])))
(pp x)
(pp y)
(pp (nd/+ x y))
(pp (nd/- x y))
(pp (nd/* x y))
(pp (nd// x y))
(pp (nd/** x y))
(pp (nd/exp x))
#+end_src


#+RESULTS:
#+begin_example
ND: (2, 2) cpu() int32
[[ 1,  2],
 [ 4,  8],
]
ND: (2, 2) cpu() int32
[[ 2,  2],
 [ 2,  2],
]
ND: (2, 2) cpu() int32
[[ 3,  4],
 [ 6, 10],
]
ND: (2, 2) cpu() int32
[[-1,  0],
 [ 2,  6],
]
ND: (2, 2) cpu() int32
[[ 2,  4],
 [ 8, 16],
]
ND: (2, 2) cpu() float32
[[0.5, 1. ],
 [2. , 4. ],
]
ND: (2, 2) cpu() int32
[[ 1,  4],
 [16, 64],
]
ND: (2, 2) cpu() int32
[[   2,    7],
 [  54, 2980],
]
#+end_example

#+begin_src clojure :results output :exports both
(pp (nd/= x y))
#+end_src

#+RESULTS:
: ND: (2, 2) cpu() boolean
: [[false,  true],
:  [false, false],
: ]

#+begin_src clojure :results output :exports both
(def X (-> (nd/arange ndm 0 12) (nd/reshape [3 4])))
(def Y (nd/create ndm (int-array [2, 1, 4, 3, 1, 2, 3, 4, 4, 3, 2, 1]) (nd/shape [3 4])))
(pp (nd/concat X Y))
(pp (nd/concat X Y :axis 0))
(pp (nd/concat X Y :axis 1))
#+end_src

#+RESULTS:
#+begin_example
ND: (6, 4) cpu() int32
[[ 0,  1,  2,  3],
 [ 4,  5,  6,  7],
 [ 8,  9, 10, 11],
 [ 2,  1,  4,  3],
 [ 1,  2,  3,  4],
 [ 4,  3,  2,  1],
]
ND: (6, 4) cpu() int32
[[ 0,  1,  2,  3],
 [ 4,  5,  6,  7],
 [ 8,  9, 10, 11],
 [ 2,  1,  4,  3],
 [ 1,  2,  3,  4],
 [ 4,  3,  2,  1],
]
ND: (3, 8) cpu() int32
[[ 0,  1,  2,  3,  2,  1,  4,  3],
 [ 4,  5,  6,  7,  1,  2,  3,  4],
 [ 8,  9, 10, 11,  4,  3,  2,  1],
]
#+end_example

#+begin_src clojure :results output :exports both
(pp (nd/= X Y))
#+end_src

#+RESULTS:
: ND: (3, 4) cpu() boolean
: [[false,  true, false,  true],
:  [false, false, false, false],
:  [false, false, false, false],
: ]

#+begin_src clojure :results output :exports both
(pp (nd/sum X))
#+end_src

#+RESULTS:
: ND: () cpu() int32
: 66

** Broadcasting Mechanism

** Indexing and Slicing

** Saving Memory
