#+PROPERTY: header-args    :tangle src/clj_d2l/data_manipulation.clj
* Data Manipulation

** Getting Started

#+begin_src clojure :results silent
(ns clj-d2l.data-manipulation
  (:require [clj-djl.ndarray :as nd]
            [clj-d2l.core :as d2l])
  (:import [ai.djl.ndarray.types DataType]))
#+end_src

Create a vector from in range 0 - 11:

#+begin_src clojure :results output :exports both
(def ndm (nd/new-base-manager))
(d2l/pp ndm)
#+end_src

#+RESULTS:
: UID: 1cecdc97-c60f-40ae-870d-d9fb3a3d2439 Parent UID: 54c4cd9f-49c0-45f2-8507-507a815372c9 isOpen: true Resource size: 0

#+begin_src clojure :results output :exports both
(def x (nd/arange ndm 0 12))
(d2l/pp x)
#+end_src

#+RESULTS:
: ND: (12) cpu() int32
: [ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11]

#+begin_src clojure :results output :exports both
(d2l/ppln (nd/get-shape x))
(d2l/pp (nd/size x))
#+end_src

#+RESULTS:
: (12)
: 12

#+begin_src clojure :results output :exports both
(def y (nd/reshape x [3 4]))
(d2l/pp y)
#+end_src

#+RESULTS:
: ND: (3, 4) cpu() int32
: [[ 0,  1,  2,  3],
:  [ 4,  5,  6,  7],
:  [ 8,  9, 10, 11],
: ]


automatically inference the rest dimention specified with =-1=:

#+begin_src clojure :results output :exports both
(def y (nd/reshape x [3 -1]))
(d2l/pp y)
#+end_src

#+RESULTS:
: ND: (3, 4) cpu() int32
: [[ 0,  1,  2,  3],
:  [ 4,  5,  6,  7],
:  [ 8,  9, 10, 11],
: ]


#+begin_src clojure :results output :exports both
(d2l/pp (nd/shape 2 3))
#+end_src

#+RESULTS:
: (2, 3)

#+begin_src clojure :results output :exports both
(d2l/pp (nd/create ndm (int-array [2 3])))
#+end_src

#+RESULTS:
: ND: (2) cpu() int32
: [ 2,  3]

#+begin_src clojure :results output :exports both
(d2l/pp (nd/zeros ndm [2 3]))
(d2l/pp (nd/zeros ndm [2 3 4]))
(d2l/pp (nd/zeros ndm [2 2 2 2]))
#+end_src

#+RESULTS:
#+begin_example
ND: (2, 3) cpu() float32
[[0., 0., 0.],
 [0., 0., 0.],
]
ND: (2, 3, 4) cpu() float32
[[[0., 0., 0., 0.],
  [0., 0., 0., 0.],
  [0., 0., 0., 0.],
 ],
 [[0., 0., 0., 0.],
  [0., 0., 0., 0.],
  [0., 0., 0., 0.],
 ],
]
ND: (2, 2, 2, 2) cpu() float32
[[[[0., 0.],
   [0., 0.],
  ],
  [[0., 0.],
   [0., 0.],
  ],
 ],
 [[[0., 0.],
   [0., 0.],
  ],
  [[0., 0.],
   [0., 0.],
  ],
 ],
]
#+end_example

#+begin_src clojure :results output :exports both
(d2l/pp (nd/ones ndm [2 3]))
(d2l/pp (nd/ones ndm [2 3 4]))
(d2l/pp (nd/ones ndm [2 2 2 2]))
#+end_src

#+RESULTS:
#+begin_example
ND: (2, 3) cpu() float32
[[1., 1., 1.],
 [1., 1., 1.],
]
ND: (2, 3, 4) cpu() float32
[[[1., 1., 1., 1.],
  [1., 1., 1., 1.],
  [1., 1., 1., 1.],
 ],
 [[1., 1., 1., 1.],
  [1., 1., 1., 1.],
  [1., 1., 1., 1.],
 ],
]
ND: (2, 2, 2, 2) cpu() float32
[[[[1., 1.],
   [1., 1.],
  ],
  [[1., 1.],
   [1., 1.],
  ],
 ],
 [[[1., 1.],
   [1., 1.],
  ],
  [[1., 1.],
   [1., 1.],
  ],
 ],
]
#+end_example


#+begin_src clojure :results output :exports both
(d2l/pp (nd/random-normal ndm 0 1 [3 4] DataType/FLOAT32))
(d2l/pp (nd/random-normal ndm 0 1 [3 4] :float64))
#+end_src

#+RESULTS:
#+begin_example
ND: (3, 4) cpu() float32
[[ 1.1105, -1.0712, -1.6029,  0.4544],
 [ 0.4841, -0.4077,  0.5432, -0.1655],
 [-0.4783,  0.0856, -1.4222, -0.2684],
]
ND: (3, 4) cpu() float64
[[ 0.5432, -0.4869,  1.1627, -0.5813],
 [-0.1686, -0.5304, -0.8469, -0.6678],
 [-0.3038,  0.331 , -0.2769,  0.9242],
]
#+end_example

#+begin_src clojure :results output :exports both
(d2l/pp (nd/random-normal ndm [3 4]))
#+end_src

#+RESULTS:
: ND: (3, 4) cpu() float32
: [[ 0.2012, -1.0064, -0.563 , -0.715 ],
:  [-0.1005, -1.2463,  0.7311,  0.0208],
:  [-0.0599,  1.5089, -1.2496,  0.3568],
: ]

** Operations

#+begin_src clojure :results output :exports both
(d2l/pp (nd/create ndm (int-array [2 1 4 3]) (nd/shape [2 2])))
(d2l/pp (nd/create ndm [2 1 4 3] [2 2]))
(d2l/pp (nd/create ndm [(int 2) 1 4 3] [2 2]))
#+end_src

#+RESULTS:
#+begin_example
ND: (2, 2) cpu() int32
[[ 2,  1],
 [ 4,  3],
]
ND: (2, 2) cpu() int64
[[ 2,  1],
 [ 4,  3],
]
ND: (2, 2) cpu() int32
[[ 2,  1],
 [ 4,  3],
]
#+end_example

#+begin_src clojure :results output :exports both
(def x (nd/create ndm [1. 2 4 8] [2 2]))
(def y (nd/create ndm [2. 2 2 2] [2 2]))
(d2l/pp x)
(d2l/pp y)
(d2l/pp (nd/+ x y))
(d2l/pp (nd/- x y))
(d2l/pp (nd/* x y))
(d2l/pp (nd// x y))
(d2l/pp (nd/** x y))
(d2l/pp (nd/exp x))
#+end_src


#+RESULTS:
#+begin_example
ND: (2, 2) cpu() float64
[[1., 2.],
 [4., 8.],
]
ND: (2, 2) cpu() float64
[[2., 2.],
 [2., 2.],
]
ND: (2, 2) cpu() float64
[[ 3.,  4.],
 [ 6., 10.],
]
ND: (2, 2) cpu() float64
[[-1.,  0.],
 [ 2.,  6.],
]
ND: (2, 2) cpu() float64
[[ 2.,  4.],
 [ 8., 16.],
]
ND: (2, 2) cpu() float64
[[0.5, 1. ],
 [2. , 4. ],
]
ND: (2, 2) cpu() float64
[[ 1.,  4.],
 [16., 64.],
]
ND: (2, 2) cpu() float64
[[ 2.71828183e+00,  7.38905610e+00],
 [ 5.45981500e+01,  2.98095799e+03],
]
#+end_example

#+begin_src clojure :results output :exports both
(d2l/pp x)
(d2l/pp y)
(d2l/pp (nd/= x y))
#+end_src

#+RESULTS:
#+begin_example
ND: (2, 2) cpu() float64
[[1., 2.],
 [4., 8.],
]
ND: (2, 2) cpu() float64
[[2., 2.],
 [2., 2.],
]
ND: (2, 2) cpu() boolean
[[false,  true],
 [false, false],
]
#+end_example

#+begin_src clojure :results output :exports both
(def X (-> (nd/arange ndm 0 12) (nd/reshape [3 4])))
(def Y (nd/create ndm (int-array [2, 1, 4, 3, 1, 2, 3, 4, 4, 3, 2, 1]) [3 4]))
(d2l/pp (nd/concat X Y))
(d2l/pp (nd/concat X Y 0))
(d2l/pp (nd/concat X Y 1))
#+end_src

#+RESULTS:
#+begin_example
ND: (6, 4) cpu() int32
[[ 0,  1,  2,  3],
 [ 4,  5,  6,  7],
 [ 8,  9, 10, 11],
 [ 2,  1,  4,  3],
 [ 1,  2,  3,  4],
 [ 4,  3,  2,  1],
]
ND: (6, 4) cpu() int32
[[ 0,  1,  2,  3],
 [ 4,  5,  6,  7],
 [ 8,  9, 10, 11],
 [ 2,  1,  4,  3],
 [ 1,  2,  3,  4],
 [ 4,  3,  2,  1],
]
ND: (3, 8) cpu() int32
[[ 0,  1,  2,  3,  2,  1,  4,  3],
 [ 4,  5,  6,  7,  1,  2,  3,  4],
 [ 8,  9, 10, 11,  4,  3,  2,  1],
]
#+end_example

#+begin_src clojure :results output :exports both
(d2l/pp (nd/= X Y))
#+end_src

#+RESULTS:
: ND: (3, 4) cpu() boolean
: [[false,  true, false,  true],
:  [false, false, false, false],
:  [false, false, false, false],
: ]

#+begin_src clojure :results output :exports both
(d2l/pp (nd/sum X))
#+end_src

#+RESULTS:
: ND: () cpu() int32
: 66

** Broadcasting Mechanism

#+begin_src clojure :results output :exports both
(def a (-> (nd/arange ndm 3) (nd/reshape [3 1])))
(d2l/pp a)
(def b (-> (nd/arange ndm 2) (nd/reshape [1 2])))
(d2l/pp b)
(d2l/pp (nd/+ a b))
#+end_src

#+RESULTS:
#+begin_example
ND: (3, 1) cpu() int32
[[ 0],
 [ 1],
 [ 2],
]
ND: (1, 2) cpu() int32
[[ 0,  1],
]
ND: (3, 2) cpu() int32
[[ 0,  1],
 [ 1,  2],
 [ 2,  3],
]
#+end_example


** Indexing and Slicing

#+begin_src clojure :results output :exports both
(d2l/pp X)
(d2l/pp (nd/get X "-1"))
(d2l/pp (nd/get X "1:3"))
(d2l/pp (nd/set X "1,2" 9))
(d2l/pp (nd/set X "0:2,:" 12))
#+end_src

#+RESULTS:
#+begin_example
ND: (3, 4) cpu() int32
[[ 0,  1,  2,  3],
 [ 4,  5,  6,  7],
 [ 8,  9, 10, 11],
]
ND: (4) cpu() int32
[ 8,  9, 10, 11]
ND: (2, 4) cpu() int32
[[ 4,  5,  6,  7],
 [ 8,  9, 10, 11],
]
ND: (3, 4) cpu() int32
[[ 0,  1,  2,  3],
 [ 4,  5,  9,  7],
 [ 8,  9, 10, 11],
]
ND: (3, 4) cpu() int32
[[12, 12, 12, 12],
 [12, 12, 12, 12],
 [ 8,  9, 10, 11],
]
#+end_example


** Saving Memory

#+begin_src clojure :results output :exports both
(def original (nd/zeros ndm (nd/get-shape X)))
(def actual (nd/+ original X))
(d2l/pp original)
(d2l/pp actual)
(println (identical? original actual))
(def copy (nd/+! original X))
(d2l/pp original)
(d2l/pp copy)
(println (identical? original copy))
#+end_src

#+RESULTS:
#+begin_example
ND: (3, 4) cpu() float32
[[0., 0., 0., 0.],
 [0., 0., 0., 0.],
 [0., 0., 0., 0.],
]
ND: (3, 4) cpu() float32
[[12., 12., 12., 12.],
 [12., 12., 12., 12.],
 [ 8.,  9., 10., 11.],
]
false
ND: (3, 4) cpu() float32
[[12., 12., 12., 12.],
 [12., 12., 12., 12.],
 [ 8.,  9., 10., 11.],
]
ND: (3, 4) cpu() float32
[[12., 12., 12., 12.],
 [12., 12., 12., 12.],
 [ 8.,  9., 10., 11.],
]
true
#+end_example

#+begin_src clojure :results output :exports both
(def original (nd/zeros-like X))
(def actual (nd/+ original X))
(d2l/pp original)
(d2l/pp actual)
(println (identical? original actual))
(def copy (nd/+! original X))
(d2l/pp original)
(d2l/pp copy)
(println (identical? original copy))
#+end_src

#+RESULTS:
#+begin_example
ND: (3, 4) cpu() int32
[[ 0,  0,  0,  0],
 [ 0,  0,  0,  0],
 [ 0,  0,  0,  0],
]
ND: (3, 4) cpu() int32
[[12, 12, 12, 12],
 [12, 12, 12, 12],
 [ 8,  9, 10, 11],
]
false
ND: (3, 4) cpu() int32
[[12, 12, 12, 12],
 [12, 12, 12, 12],
 [ 8,  9, 10, 11],
]
ND: (3, 4) cpu() int32
[[12, 12, 12, 12],
 [12, 12, 12, 12],
 [ 8,  9, 10, 11],
]
true
#+end_example

** Conversion to Other Clojure Objects

#+begin_src clojure :results output :exports both

(d2l/ppln (type (nd/to-vec X)))
(d2l/ppln (nd/to-vec X))
(d2l/ppln (type (nd/to-array X)))
(d2l/ppln (type X))
(d2l/pp X)
#+end_src

#+RESULTS:
: class clojure.lang.PersistentVector
: [12 12 12 12 12 12 12 12 8 9 10 11]
: class [Ljava.lang.Integer;
: class ai.djl.mxnet.engine.MxNDArray
: ND: (3, 4) cpu() int32
: [[12, 12, 12, 12],
:  [12, 12, 12, 12],
:  [ 8,  9, 10, 11],
: ]

To convert a size-1 tensor to a scalar

#+begin_src clojure :results output :exports both
(def a (nd/create ndm [3.5]))
(d2l/pp a)
(println (nd/get-element a))
#+end_src

#+RESULTS:
: ND: (1) cpu() float64
: [3.5]
: 3.5
