<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-05-17 Tue 08:06 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>&lrm;</title>
<meta name="author" content="Kimi Ma" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
</style>
<link rel="stylesheet" type="text/css" href="css/style.css" />
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="sitemap.html"> UP </a>
 |
 <a accesskey="H" href="index.html"> HOME </a>
</div><div id="content" class="content">
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org1002a1b">1. Data Manipulation</a>
<ul>
<li><a href="#org761ea4a">1.1. Getting Started</a></li>
<li><a href="#org6f4bf44">1.2. Operations</a>
<ul>
<li><a href="#orgcbc24fd">1.2.1. Operations</a></li>
</ul>
</li>
<li><a href="#org7d15ed0">1.3. Broadcasting Mechanism</a></li>
<li><a href="#org61b17a7">1.4. Indexing and Slicing</a></li>
<li><a href="#org54f7ef4">1.5. Saving Memory</a></li>
<li><a href="#org8ebfc39">1.6. Conversion to Other Clojure Objects</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org1002a1b" class="outline-2">
<h2 id="org1002a1b"><span class="section-number-2">1.</span> Data Manipulation</h2>
<div class="outline-text-2" id="text-1">
<p>
In order to get anything done, we need some way to store and
manipulate data. Generally, there are two important things we need
to do with data: (i) acquire them; and (ii) process them once they
are inside the computer. There is no point in acquiring data without
some way to store it, so let us get our hands dirty first by playing
with synthetic data. To start, we introduce the $n$-dimensional
array, which is also called the <i>ndarray</i>.
</p>

<p>
If you have worked with NumPy, the most widely-used scientific
computing package in Python, then you will find this section
familiar. No matter which framework you use, its tensor class
(<i>ndarray</i> in MXNet, DJL and clj-djl, <i>Tensor</i> in both PyTorch and
TensorFlow) is similar to NumPy&rsquo;s ndarray with a few killer
features. First, GPU is well-supported to accelerate the computation
whereas NumPy only supports CPU computation. Second, the tensor
class supports automatic differentiation. These properties make the
tensor class suitable for deep learning. Throughout the book, when
we say ndarrays, we are referring to instances of the ndarray class
unless otherwise stated.
</p>
</div>

<div id="outline-container-org761ea4a" class="outline-3">
<h3 id="org761ea4a"><span class="section-number-3">1.1.</span> Getting Started</h3>
<div class="outline-text-3" id="text-1-1">
<p>
In this section, we aim to get you up and running, equipping you
with the basic math and numerical computing tools that you will
build on as you progress through the book. Do not worry if you
struggle to grok some of the mathematical concepts or library
functions. The following sections will revisit this material in the
context of practical examples and it will sink. On the other hand,
if you already have some background and want to go deeper into the
mathematical content, just skip this section.
</p>

<p>
To start, we import the ndarray namespace from clj-djl. Here, the
ndarray namespace includes functions supported by clj-djl.
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #707183;">(</span><span style="color: #7F0055; font-weight: bold;">ns</span> <span style="color: #000000; font-style: italic; text-decoration: underline;">clj-d2l.data-manipulation</span>
  <span style="color: #7388d6;">(</span><span style="color: #110099;">:require</span> <span style="color: #909183;">[</span>clj-djl.ndarray <span style="color: #110099;">:as</span> nd<span style="color: #909183;">]</span>
            <span style="color: #909183;">[</span>clj-d2l.core <span style="color: #110099;">:as</span> d2l<span style="color: #909183;">]</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
</pre>
</div>

<p>
An ndarray represents a (possibly multi-dimensional) array of
numerical values. With one axis, an ndarray corresponds (in math) to
a vector. With two axes, an ndarray corresponds to a
matrix. NDArrays with more than two axes do not have special
mathematical names.
</p>

<p>
To start, we can use arange to create a row vector x containing the
first 12 integers starting with 0. Each of the values in an ndarray
is called an element of the ndarray. For instance, there are 12
elements in the ndarray x. Unless otherwise specified, a new ndarray
will be stored in main memory and designated for CPU-based
computation.
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #707183;">(</span><span style="color: #7F0055; font-weight: bold;">def</span> <span style="color: #000000;">ndm</span> <span style="color: #7388d6;">(</span><span style="color: #000000; font-style: italic; text-decoration: underline;">nd</span>/base-manager<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
<span style="color: #707183;">(</span><span style="color: #7F0055; font-weight: bold;">def</span> <span style="color: #000000;">x</span> <span style="color: #7388d6;">(</span><span style="color: #000000; font-style: italic; text-decoration: underline;">nd</span>/arange ndm 0 12<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
x
</pre>
</div>

<pre class="example">
ND: (12) cpu() int32
[ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11]
</pre>


<p>
We can access an ndarray&rsquo;s shape (the length along each axis) by
inspecting its shape property.
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #707183;">(</span><span style="color: #000000; font-style: italic; text-decoration: underline;">nd</span>/shape x<span style="color: #707183;">)</span>
</pre>
</div>

<pre class="example">
(12)
</pre>


<p>
If we just want to know the total number of elements in an ndarray,
i.e., the product of all of the shape elements, we can inspect its
size. Because we are dealing with a vector here, the single element
of its shape is same to its size. The difference is that <code>shape</code>
will return a <i>Shape</i> object.
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #707183;">(</span><span style="color: #000000; font-style: italic; text-decoration: underline;">nd</span>/size x<span style="color: #707183;">)</span>
</pre>
</div>

<pre class="example">
12
</pre>


<p>
To change the shape of an ndarray without altering either the number
of elements or their values, we can invoke the <code>reshape</code> function. For
example, we can transform our ndarray, x, from a row vector with
shape (12) to a matrix with shape (3, 4). This new ndarray contains
the exact same values, but views them as a matrix organized as 3
rows and 4 columns. To reiterate, although the shape has changed,
the elements have not. Note that the size is unaltered by reshaping.
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #707183;">(</span><span style="color: #7F0055; font-weight: bold;">def</span> <span style="color: #000000;">y</span> <span style="color: #7388d6;">(</span><span style="color: #000000; font-style: italic; text-decoration: underline;">nd</span>/reshape x <span style="color: #909183;">[</span>3 4<span style="color: #909183;">]</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
y
</pre>
</div>

<pre class="example">
ND: (3, 4) cpu() int32
[[ 0,  1,  2,  3],
 [ 4,  5,  6,  7],
 [ 8,  9, 10, 11],
]
</pre>


<p>
Reshaping by manually specifying every dimension is unnecessary. If
our target shape is a matrix with shape (height, width), then after we
know the width, the height is given implicitly. Why should we have to
perform the division ourselves? In the example above, to get a matrix
with 3 rows, we specified both that it should have 3 rows and 4
columns. Fortunately, ndarrays can automatically work out one
dimension given the rest. We invoke this capability by placing -1 for
the dimension that we would like ndarrays to automatically infer. In
our case, instead of calling <code>(reshape x [3 4])</code>, we could have
equivalently called <code>(nd/reshape x [-1 4])</code> or <code>(nd/reshape x [3 -1])</code>.
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #707183;">(</span><span style="color: #7F0055; font-weight: bold;">def</span> <span style="color: #000000;">y</span> <span style="color: #7388d6;">(</span><span style="color: #000000; font-style: italic; text-decoration: underline;">nd</span>/reshape x <span style="color: #909183;">[</span>3 -1<span style="color: #909183;">]</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
y
</pre>
</div>

<pre class="example">
ND: (3, 4) cpu() int32
[[ 0,  1,  2,  3],
 [ 4,  5,  6,  7],
 [ 8,  9, 10, 11],
]
</pre>


<p>
Passing create method with only Shape will grab a chunk of memory and
hands us back a matrix without bothering to change the value of any of
its entries. This is remarkably efficient but we must be careful
because the entries might take arbitrary values, including very big
ones!
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #707183;">(</span><span style="color: #000000; font-style: italic; text-decoration: underline;">nd</span>/create ndm <span style="color: #7388d6;">(</span><span style="color: #000000; font-style: italic; text-decoration: underline;">nd</span>/shape <span style="color: #909183;">[</span>3 4<span style="color: #909183;">]</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
</pre>
</div>

<pre class="example">
ND: (3, 4) cpu() float32
[[ 0.00000000e+00,  0.00000000e+00,  0.00000000e+00,  0.00000000e+00],
 [ 1.21782351e+29,  0.00000000e+00,  1.21783258e+29,  0.00000000e+00],
 [ 1.19888078e+29,  0.00000000e+00,  1.21744119e+29,  0.00000000e+00],
]
</pre>


<p>
Typically, we will want our matrices initialized either with zeros,
ones, some other constants, or numbers randomly sampled from a
specific distribution. We can create a ndarray representing a tensor
with all elements set to 0 and a shape of <code>[2 3 4]</code> as follows:
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #707183;">(</span><span style="color: #000000; font-style: italic; text-decoration: underline;">nd</span>/zeros ndm <span style="color: #7388d6;">[</span>2 3 4<span style="color: #7388d6;">]</span><span style="color: #707183;">)</span>
</pre>
</div>

<pre class="example" id="orgcaefbe4">
ND: (2, 3, 4) cpu() float32
[[[0., 0., 0., 0.],
  [0., 0., 0., 0.],
  [0., 0., 0., 0.],
 ],
 [[0., 0., 0., 0.],
  [0., 0., 0., 0.],
  [0., 0., 0., 0.],
 ],
]
</pre>

<p>
Similarly, we can create ndarrays with each element set to 1 as follows:
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #707183;">(</span><span style="color: #000000; font-style: italic; text-decoration: underline;">nd</span>/ones ndm <span style="color: #7388d6;">[</span>2 3 4<span style="color: #7388d6;">]</span><span style="color: #707183;">)</span>
</pre>
</div>

<pre class="example" id="org5005ac7">
ND: (2, 3, 4) cpu() float32
[[[1., 1., 1., 1.],
  [1., 1., 1., 1.],
  [1., 1., 1., 1.],
 ],
 [[1., 1., 1., 1.],
  [1., 1., 1., 1.],
  [1., 1., 1., 1.],
 ],
]
</pre>

<p>
Often, we want to randomly sample the values for each element in an
ndarray from some probability distribution. For example, when we
construct arrays to serve as parameters in a neural network, we will
typically initialize their values randomly. The following snippet
creates an ndarray with shape (3, 4). Each of its elements is randomly
sampled from a standard Gaussian (normal) distribution with a mean of
0 and a standard deviation of 1.
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #707183;">(</span><span style="color: #000000; font-style: italic; text-decoration: underline;">nd</span>/random-normal ndm 0 1 <span style="color: #7388d6;">(</span><span style="color: #000000; font-style: italic; text-decoration: underline;">nd</span>/shape <span style="color: #909183;">[</span>3 4<span style="color: #909183;">]</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
</pre>
</div>

<pre class="example">
ND: (3, 4) cpu() float32
[[ 1.1631,  2.2122,  0.4838,  0.774 ],
 [ 0.2996,  1.0434,  0.153 ,  1.1839],
 [-1.1688,  1.8917,  1.5581, -1.2347],
]
</pre>


<p>
We can directly use a clojure vec as the shape:
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #707183;">(</span><span style="color: #000000; font-style: italic; text-decoration: underline;">nd</span>/random-normal ndm 0 1 <span style="color: #7388d6;">[</span>3 4<span style="color: #7388d6;">]</span><span style="color: #707183;">)</span>
</pre>
</div>

<pre class="example">
ND: (3, 4) cpu() float32
[[-0.5459, -1.771 , -2.3556, -0.4514],
 [ 0.5414,  0.5794,  2.6785, -1.8561],
 [ 1.2546, -1.9769, -0.5488, -0.208 ],
]
</pre>


<p>
You can also just pass the shape and it will use default values for mean and
standard deviation (0 and 1).
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #707183;">(</span><span style="color: #000000; font-style: italic; text-decoration: underline;">nd</span>/random-normal ndm <span style="color: #7388d6;">[</span>3 4<span style="color: #7388d6;">]</span><span style="color: #707183;">)</span>
</pre>
</div>

<pre class="example">
ND: (3, 4) cpu() float32
[[-0.6811,  0.2444, -0.1353, -0.0372],
 [ 0.3772, -0.4877,  0.4102, -0.0226],
 [ 0.5713,  0.5746, -2.758 ,  1.4661],
]
</pre>


<p>
We can also specify the exact values for each element in the desired ndarray by
supplying a clojure vec (or list) containing the numerical values. Here, the
outermost list corresponds to axis 0, and the inner list to axis 1.
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #707183;">(</span><span style="color: #000000; font-style: italic; text-decoration: underline;">nd</span>/create ndm <span style="color: #7388d6;">[</span>2 1 4 3 1 2 3 4 4 3 2 1<span style="color: #7388d6;">]</span> <span style="color: #7388d6;">[</span>3 4<span style="color: #7388d6;">]</span><span style="color: #707183;">)</span>
</pre>
</div>

<pre class="example">
ND: (3, 4) cpu() int64
[[ 2,  1,  4,  3],
 [ 1,  2,  3,  4],
 [ 4,  3,  2,  1],
]
</pre>


<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #707183;">(</span><span style="color: #000000; font-style: italic; text-decoration: underline;">nd</span>/create ndm <span style="color: #7388d6;">[</span><span style="color: #909183;">[</span>2 1 4 3<span style="color: #909183;">][</span>1 2 3 4<span style="color: #909183;">][</span>4 3 2 1<span style="color: #909183;">]</span><span style="color: #7388d6;">]</span><span style="color: #707183;">)</span>
</pre>
</div>

<pre class="example">
ND: (3, 4) cpu() int64
[[ 2,  1,  4,  3],
 [ 1,  2,  3,  4],
 [ 4,  3,  2,  1],
]
</pre>
</div>
</div>

<div id="outline-container-org6f4bf44" class="outline-3">
<h3 id="org6f4bf44"><span class="section-number-3">1.2.</span> Operations</h3>
<div class="outline-text-3" id="text-1-2">
<p>
This book is not about software engineering. Our interests are not
limited to simply reading and writing data from/to arrays. We want to
perform mathematical operations on those arrays. Some of the simplest
and most useful operations are the elementwise operations. These apply
a standard scalar operation to each element of an array. For functions
that take two arrays as inputs, elementwise operations apply some
standard binary operator on each pair of corresponding elements from
the two arrays. We can create an elementwise function from any
function that maps from a scalar to a scalar.
</p>

<p>
In mathematical notation, we would denote such a unary scalar operator
(taking one input) by the signature \(f: \mathbb{R} \ rightarrow
\mathbb{R}\). This just means that the function is mapping from any
real number (\(\mathbb{R}\)) onto another. Likewise, we denote a binary
scalar operator (taking two real inputs, and yielding one output) by
the signature \(f: \mathbb{R}, \mathbb{R} \rightarrow
\mathbb{R}\). Given any two vectors \(\mathbf{u}\) and \(\mathbf{v}\) <b>of
the same shape</b>, and a binary operator \(f\), we can produce a vector
\(\mathbf{c} = F(\mathbf{u}, \mathbf{v})\) by setting \(c_i \gets f(u_i,
v_i)\) for all \(i\), where \(c_i, u_i\), and \(v_i\) are the \(i^\mathrm{th}\)
elements of vectors \(\mathbf{c}\), \(\mathbf{u}\), and
\(\mathbf{v}\). Here, we produced the vector-valued \(F: \mathbb{R}^d,
\mathbb{R}^d \rightarrow \mathbb{R}^d\) by <b>lifting</b> the scalar function
to an elementwise vector operation.
</p>

<p>
The common standard arithmetic operators (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>) have all been
<b>lifted</b> to elementwise operations for any identically-shaped ndarrays
of arbitrary shape. We can call elementwise operations on any two
ndarrays of the same shape. In the following example, we use commas to
formulate a 5-element tuple, where each element is the result of an
elementwise operation.
</p>
</div>

<div id="outline-container-orgcbc24fd" class="outline-4">
<h4 id="orgcbc24fd"><span class="section-number-4">1.2.1.</span> Operations</h4>
<div class="outline-text-4" id="text-1-2-1">
<p>
The common standard arithmetic operators (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>) have all been
lifted to elementwise operations.
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #707183;">(</span><span style="color: #7F0055; font-weight: bold;">def</span> <span style="color: #000000;">x</span> <span style="color: #7388d6;">(</span><span style="color: #000000; font-style: italic; text-decoration: underline;">nd</span>/create ndm <span style="color: #909183;">[</span>1. 2. 4. 8.<span style="color: #909183;">]</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
<span style="color: #707183;">(</span><span style="color: #7F0055; font-weight: bold;">def</span> <span style="color: #000000;">y</span> <span style="color: #7388d6;">(</span><span style="color: #000000; font-style: italic; text-decoration: underline;">nd</span>/create ndm <span style="color: #909183;">[</span>2. 2. 2. 2.<span style="color: #909183;">]</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
<span style="color: #707183;">(</span><span style="color: #000000; font-style: italic; text-decoration: underline;">nd</span>/+ x y<span style="color: #707183;">)</span>
</pre>
</div>

<pre class="example">
ND: (4) cpu() float64
[ 3.,  4.,  6., 10.]
</pre>


<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #707183;">(</span><span style="color: #000000; font-style: italic; text-decoration: underline;">nd</span>/- x y<span style="color: #707183;">)</span>
</pre>
</div>

<pre class="example">
ND: (4) cpu() float64
[-1.,  0.,  2.,  6.]
</pre>


<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #707183;">(</span><span style="color: #000000; font-style: italic; text-decoration: underline;">nd</span>// x y<span style="color: #707183;">)</span>
</pre>
</div>

<pre class="example">
ND: (4) cpu() float64
[0.5, 1. , 2. , 4. ]
</pre>


<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #707183;">(</span><span style="color: #000000; font-style: italic; text-decoration: underline;">nd</span>/pow x y<span style="color: #707183;">)</span>
</pre>
</div>

<pre class="example">
ND: (4) cpu() float64
[ 1.,  4., 16., 64.]
</pre>


<p>
Many more operations can be applied elementwise, including unary
operators like exponentiation.
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #707183;">(</span><span style="color: #000000; font-style: italic; text-decoration: underline;">nd</span>/exp x<span style="color: #707183;">)</span>
</pre>
</div>

<pre class="example">
ND: (4) cpu() float64
[ 2.71828183e+00,  7.38905610e+00,  5.45981500e+01,  2.98095799e+03]
</pre>


<p>
In addition to elementwise computations, we can also perform linear
algebra operations, including vector dot products and matrix
multiplication. We will explain the crucial bits of linear algebra
(with no assumed prior knowledge) in -Section 2.3-.
</p>

<p>
We can also concatenate multiple ndarrays together, stacking them
end-to-end to form a larger ndarray. We just need to provide a list of
ndarrays and tell the system along which axis to concatenate. The
example below shows what happens when we concatenate two matrices
along rows (axis 0, the first element of the shape) vs. columns (axis
1, the second element of the shape). We can see that the first output
ndarray&rsquo;s shape is (6, 4), its axis-0 length (6) is the sum of the two
input ndarrays&rsquo; axis-0 lengths \((3+3)\); while the second output
ndarray&rsquo;s shape is (3, 8), its axis-1 length (8) is the sum of the two
input ndarrays&rsquo; axis-1 lengths \((4+4)\).
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #707183;">(</span><span style="color: #7F0055; font-weight: bold;">def</span> <span style="color: #000000;">X</span> <span style="color: #7388d6;">(</span><span style="color: #7F0055; font-weight: bold;">-&gt;</span> <span style="color: #909183;">(</span><span style="color: #000000; font-style: italic; text-decoration: underline;">nd</span>/arange ndm 12<span style="color: #909183;">)</span>
           <span style="color: #909183;">(</span><span style="color: #000000; font-style: italic; text-decoration: underline;">nd</span>/reshape <span style="color: #709870;">[</span>3 4<span style="color: #709870;">]</span><span style="color: #909183;">)</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
X
</pre>
</div>

<pre class="example">
ND: (3, 4) cpu() int32
[[ 0,  1,  2,  3],
 [ 4,  5,  6,  7],
 [ 8,  9, 10, 11],
]
</pre>


<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #707183;">(</span><span style="color: #7F0055; font-weight: bold;">def</span> <span style="color: #000000;">Y</span> <span style="color: #7388d6;">(</span><span style="color: #000000; font-style: italic; text-decoration: underline;">nd</span>/create ndm <span style="color: #909183;">[</span><span style="color: #709870;">[</span>2 1 4 3<span style="color: #709870;">][</span>1 2 3 4<span style="color: #709870;">][</span>4 3 2 1<span style="color: #709870;">]</span><span style="color: #909183;">]</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
Y
</pre>
</div>

<pre class="example">
ND: (3, 4) cpu() int64
[[ 2,  1,  4,  3],
 [ 1,  2,  3,  4],
 [ 4,  3,  2,  1],
]
</pre>


<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #3F7F5F;">;; </span><span style="color: #3F7F5F;">concat only support int32 and float32 datatype</span>
<span style="color: #707183;">(</span><span style="color: #7F0055; font-weight: bold;">def</span> <span style="color: #000000;">Y</span> <span style="color: #7388d6;">(</span><span style="color: #000000; font-style: italic; text-decoration: underline;">nd</span>/to-type Y <span style="color: #110099;">:int32</span> <span style="color: #110099;">false</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
<span style="color: #707183;">(</span><span style="color: #000000; font-style: italic; text-decoration: underline;">nd</span>/<span style="color: #7F0055; font-weight: bold;">concat</span> Y Y<span style="color: #707183;">)</span>
</pre>
</div>

<pre class="example">
ND: (6, 4) cpu() int32
[[ 2,  1,  4,  3],
 [ 1,  2,  3,  4],
 [ 4,  3,  2,  1],
 [ 2,  1,  4,  3],
 [ 1,  2,  3,  4],
 [ 4,  3,  2,  1],
]
</pre>


<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #707183;">(</span><span style="color: #000000; font-style: italic; text-decoration: underline;">nd</span>/<span style="color: #7F0055; font-weight: bold;">concat</span> X Y 1<span style="color: #707183;">)</span>
</pre>
</div>

<pre class="example">
ND: (3, 8) cpu() int32
[[ 0,  1,  2,  3,  2,  1,  4,  3],
 [ 4,  5,  6,  7,  1,  2,  3,  4],
 [ 8,  9, 10, 11,  4,  3,  2,  1],
]
</pre>


<p>
The third argument of <code>nd/concat</code> is to specify the axis to concatenate,
default is axis-0.
</p>

<p>
Sometimes, we want to construct a binary ndarray via logical
statements. Take <code>(nd/= X Y)</code> as an example. For each position, if X and
Y are equal at that position, the corresponding entry in the new
tensor takes a value of <code>true</code>, meaning that the logical statement <code>(nd/=
X Y)</code> is true at that position; otherwise that position takes <code>false</code>.
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #707183;">(</span><span style="color: #000000; font-style: italic; text-decoration: underline;">nd</span>/= X Y<span style="color: #707183;">)</span>
</pre>
</div>

<pre class="example">
ND: (3, 4) cpu() boolean
[[false,  true, false,  true],
 [false, false, false, false],
 [false, false, false, false],
]
</pre>


<p>
Summing all the elements in the ndarray yields a ndarray with only one
element.
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #707183;">(</span><span style="color: #000000; font-style: italic; text-decoration: underline;">nd</span>/sum X<span style="color: #707183;">)</span>
</pre>
</div>

<pre class="example">
ND: () cpu() int32
66
</pre>
</div>
</div>
</div>

<div id="outline-container-org7d15ed0" class="outline-3">
<h3 id="org7d15ed0"><span class="section-number-3">1.3.</span> Broadcasting Mechanism</h3>
<div class="outline-text-3" id="text-1-3">
<p>
In the above section, we saw how to perform elementwise operations on two
ndarrays of the same shape. Under certain conditions, even when shapes differ,
we can still perform elementwise operations by invoking the broadcasting
mechanism. This mechanism works in the following way: First, expand one or both
arrays by copying elements appropriately so that after this transformation, the
two ndarrays have the same shape. Second, carry out the elementwise operations
on the resulting arrays.
</p>

<p>
In most cases, we broadcast along an axis where an array initially only has
length 1, such as in the following example:
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #707183;">(</span><span style="color: #7F0055; font-weight: bold;">def</span> <span style="color: #000000;">a</span> <span style="color: #7388d6;">(</span><span style="color: #7F0055; font-weight: bold;">-&gt;</span> <span style="color: #909183;">(</span><span style="color: #000000; font-style: italic; text-decoration: underline;">nd</span>/arange ndm 3<span style="color: #909183;">)</span> <span style="color: #909183;">(</span><span style="color: #000000; font-style: italic; text-decoration: underline;">nd</span>/reshape <span style="color: #709870;">[</span>3 1<span style="color: #709870;">]</span><span style="color: #909183;">)</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
a
</pre>
</div>

<pre class="example">
ND: (3, 1) cpu() int32
[[ 0],
 [ 1],
 [ 2],
]
</pre>


<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #707183;">(</span><span style="color: #7F0055; font-weight: bold;">def</span> <span style="color: #000000;">b</span> <span style="color: #7388d6;">(</span><span style="color: #7F0055; font-weight: bold;">-&gt;</span> <span style="color: #909183;">(</span><span style="color: #000000; font-style: italic; text-decoration: underline;">nd</span>/arange ndm 2<span style="color: #909183;">)</span> <span style="color: #909183;">(</span><span style="color: #000000; font-style: italic; text-decoration: underline;">nd</span>/reshape <span style="color: #709870;">[</span>1 2<span style="color: #709870;">]</span><span style="color: #909183;">)</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
b
</pre>
</div>

<pre class="example">
ND: (1, 2) cpu() int32
[[ 0,  1],
]
</pre>


<p>
Since a and b are \(3 \times 1\) and \(1 \times 2\) matrices respectively,
their shapes do not match up if we want to add them. We broadcast the
entries of both matrices into a larger \(3 \times 2\) matrix as follows:
for matrix a it replicates the columns and for matrix b it replicates
the rows before adding up both elementwise.
</p>

<p>
The result of \(a\) broadcasted is:
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #707183;">(</span><span style="color: #000000; font-style: italic; text-decoration: underline;">nd</span>/<span style="color: #7F0055; font-weight: bold;">concat</span> a a 1<span style="color: #707183;">)</span>
</pre>
</div>

<pre class="example">
ND: (3, 2) cpu() int32
[[ 0,  0],
 [ 1,  1],
 [ 2,  2],
]
</pre>


<p>
The result of \(b\) broadcasted is:
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #707183;">(</span><span style="color: #7F0055; font-weight: bold;">-&gt;&gt;</span> b
     <span style="color: #7388d6;">(</span><span style="color: #000000; font-style: italic; text-decoration: underline;">nd</span>/<span style="color: #7F0055; font-weight: bold;">concat</span> b<span style="color: #7388d6;">)</span>
     <span style="color: #7388d6;">(</span><span style="color: #000000; font-style: italic; text-decoration: underline;">nd</span>/<span style="color: #7F0055; font-weight: bold;">concat</span> b<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
</pre>
</div>

<pre class="example">
ND: (3, 2) cpu() int32
[[ 0,  1],
 [ 0,  1],
 [ 0,  1],
]
</pre>


<p>
Thus the result is:
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #707183;">(</span><span style="color: #000000; font-style: italic; text-decoration: underline;">nd</span>/+ a b<span style="color: #707183;">)</span>
</pre>
</div>

<pre class="example">
ND: (3, 2) cpu() int32
[[ 0,  1],
 [ 1,  2],
 [ 2,  3],
]
</pre>
</div>
</div>

<div id="outline-container-org61b17a7" class="outline-3">
<h3 id="org61b17a7"><span class="section-number-3">1.4.</span> Indexing and Slicing</h3>
<div class="outline-text-3" id="text-1-4">
<p>
Just as in any other Python array, elements in a ndarray can be
accessed by index. As in any Python array, the first element has index
0 and ranges are specified to include the first but before the last
element. As in standard Python lists, we can access elements according
to their relative position to the end of the list by using negative
indices.
</p>

<p>
Java and Clojure do not support <code>operator[]</code> overload, a simulation is
done with index and slice string.
</p>

<div class="org-src-container">
<pre class="src src-clojure">X
</pre>
</div>

<pre class="example">
ND: (3, 4) cpu() int32
[[ 0,  1,  2,  3],
 [ 4,  5,  6,  7],
 [ 8,  9, 10, 11],
]
</pre>


<p>
Thus, [-1] selects the last element and [1:3] selects the second and the third
elements as follows:
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #707183;">(</span><span style="color: #000000; font-style: italic; text-decoration: underline;">nd</span>/<span style="color: #7F0055; font-weight: bold;">get</span> X <span style="color: #2A00FF;">"-1"</span><span style="color: #707183;">)</span>
</pre>
</div>

<pre class="example">
ND: (4) cpu() int32
[ 8,  9, 10, 11]
</pre>


<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #707183;">(</span><span style="color: #000000; font-style: italic; text-decoration: underline;">nd</span>/<span style="color: #7F0055; font-weight: bold;">get</span> X <span style="color: #2A00FF;">"1:3"</span><span style="color: #707183;">)</span>
</pre>
</div>

<pre class="example">
ND: (2, 4) cpu() int32
[[ 4,  5,  6,  7],
 [ 8,  9, 10, 11],
]
</pre>


<p>
Beyond reading, we can also set elements of a matrix by specifying indices.
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #707183;">(</span><span style="color: #000000; font-style: italic; text-decoration: underline;">nd</span>/<span style="color: #7F0055; font-weight: bold;">set</span> X <span style="color: #2A00FF;">"1,2"</span> 999<span style="color: #707183;">)</span>
</pre>
</div>

<pre class="example">
ND: (3, 4) cpu() int32
[[  0,   1,   2,   3],
 [  4,   5, 999,   7],
 [  8,   9,  10,  11],
]
</pre>


<p>
If we want to assign multiple elements the same value, we simply index all of
them and then assign them the value. For instance, [0:2, :] accesses the first
and second rows, where : takes all the elements along axis 1 (column). While we
discussed indexing for matrices, this obviously also works for vectors and for
tensors of more than 2 dimensions.
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #707183;">(</span><span style="color: #000000; font-style: italic; text-decoration: underline;">nd</span>/<span style="color: #7F0055; font-weight: bold;">set</span> X <span style="color: #2A00FF;">"0:2,:"</span> 12<span style="color: #707183;">)</span>
</pre>
</div>

<pre class="example">
ND: (3, 4) cpu() int32
[[12, 12, 12, 12],
 [12, 12, 12, 12],
 [ 8,  9, 10, 11],
]
</pre>
</div>
</div>

<div id="outline-container-org54f7ef4" class="outline-3">
<h3 id="org54f7ef4"><span class="section-number-3">1.5.</span> Saving Memory</h3>
<div class="outline-text-3" id="text-1-5">
<p>
Running operations can cause new memory to be allocated to host
results. For example, if we write <code>(def Y2 (nd/+! X Y)</code>, we will
dereference the ndarray that Y used to point to and instead point Y at
the newly allocated memory. In the following example, we demonstrate
this with Clojure&rsquo;s <code>identical?</code> function, which results <code>true</code> if the two
object are exactly the same. After running Y&rsquo; = Y + X, we will find
that Y and Y&rsquo; are different objects. That is because Clojure first
evaluates Y + X, allocating new memory for the result and then makes Y
point to this new location in memory.
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #707183;">(</span><span style="color: #7F0055; font-weight: bold;">def</span> <span style="color: #000000;">Y</span> <span style="color: #7388d6;">(</span><span style="color: #000000; font-style: italic; text-decoration: underline;">nd</span>/zeros ndm <span style="color: #909183;">(</span><span style="color: #000000; font-style: italic; text-decoration: underline;">nd</span>/get-shape X<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
<span style="color: #707183;">(</span><span style="color: #7F0055; font-weight: bold;">def</span> <span style="color: #000000;">Y</span>' <span style="color: #7388d6;">(</span><span style="color: #000000; font-style: italic; text-decoration: underline;">nd</span>/+ Y X<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
<span style="color: #707183;">(</span><span style="color: #7F0055; font-weight: bold;">identical?</span> Y Y'<span style="color: #707183;">)</span>
</pre>
</div>

<pre class="example">
false
</pre>


<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #707183;">(</span><span style="color: #7F0055; font-weight: bold;">def</span> <span style="color: #000000;">Y</span>'' <span style="color: #7388d6;">(</span><span style="color: #000000; font-style: italic; text-decoration: underline;">nd</span>/+! Y X<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
<span style="color: #707183;">(</span><span style="color: #7F0055; font-weight: bold;">identical?</span> Y Y''<span style="color: #707183;">)</span>
</pre>
</div>

<pre class="example">
true
</pre>


<p>
Running operations can cause new memory to be allocated to host
results. For example, if we write y = x.add(y), we will dereference
the ndarray that y used to point to and instead point y at the newly
allocated memory.
</p>

<p>
This might be undesirable for two reasons. First, we do not want to
run around allocating memory unnecessarily all the time. In machine
learning, we might have hundreds of megabytes of parameters and update
all of them multiple times per second. Typically, we will want to
perform these updates in place. Second, we might point at the same
parameters from multiple variables. If we do not update in place,
other references will still point to the old memory location, making
it possible for parts of our code to inadvertently reference stale
parameters.
</p>

<p>
Fortunately, performing in-place operations in DJL is easy. We can
assign the result of an operation to a previously allocated array
using inplace operators like addi, subi, muli, and divi.
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #707183;">(</span><span style="color: #7F0055; font-weight: bold;">def</span> <span style="color: #000000;">Y</span> <span style="color: #7388d6;">(</span><span style="color: #000000; font-style: italic; text-decoration: underline;">nd</span>/zeros ndm <span style="color: #909183;">(</span><span style="color: #000000; font-style: italic; text-decoration: underline;">nd</span>/get-shape X<span style="color: #909183;">)</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
<span style="color: #707183;">(</span><span style="color: #7F0055; font-weight: bold;">def</span> <span style="color: #000000;">Y</span>' <span style="color: #7388d6;">(</span><span style="color: #000000; font-style: italic; text-decoration: underline;">nd</span>/+ Y X<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
<span style="color: #707183;">(</span><span style="color: #7F0055; font-weight: bold;">identical?</span> Y Y'<span style="color: #707183;">)</span>
</pre>
</div>

<pre class="example">
false
</pre>


<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #707183;">(</span><span style="color: #7F0055; font-weight: bold;">def</span> <span style="color: #000000;">Y</span>'' <span style="color: #7388d6;">(</span><span style="color: #000000; font-style: italic; text-decoration: underline;">nd</span>/+! Y X<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
<span style="color: #707183;">(</span><span style="color: #7F0055; font-weight: bold;">identical?</span> Y Y''<span style="color: #707183;">)</span>
</pre>
</div>

<pre class="example">
true
</pre>
</div>
</div>

<div id="outline-container-org8ebfc39" class="outline-3">
<h3 id="org8ebfc39"><span class="section-number-3">1.6.</span> Conversion to Other Clojure Objects</h3>
<div class="outline-text-3" id="text-1-6">
<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #707183;">(</span><span style="color: #7F0055; font-weight: bold;">type</span> <span style="color: #7388d6;">(</span><span style="color: #000000; font-style: italic; text-decoration: underline;">nd</span>/to-vec X<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
</pre>
</div>

<pre class="example">
class clojure.lang.PersistentVector
</pre>


<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #707183;">(</span><span style="color: #000000; font-style: italic; text-decoration: underline;">nd</span>/to-vec X<span style="color: #707183;">)</span>
</pre>
</div>

<pre class="example">
[12 12 12 12 12 12 12 12 8 9 10 11]
</pre>


<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #707183;">(</span>type <span style="color: #7388d6;">(</span><span style="color: #000000; font-style: italic; text-decoration: underline;">nd</span>/<span style="color: #7F0055; font-weight: bold;">to-array</span> X<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
</pre>
</div>

<pre class="example">
class [Ljava.lang.Integer;
</pre>


<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #707183;">(</span><span style="color: #7F0055; font-weight: bold;">type</span> X<span style="color: #707183;">)</span>
</pre>
</div>

<pre class="example">
class ai.djl.mxnet.engine.MxNDArray
</pre>


<div class="org-src-container">
<pre class="src src-clojure">X
</pre>
</div>

<pre class="example">
ND: (3, 4) cpu() int32
[[12, 12, 12, 12],
 [12, 12, 12, 12],
 [ 8,  9, 10, 11],
]
</pre>


<p>
To convert a size-1 tensor to a scalar
</p>

<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #707183;">(</span><span style="color: #7F0055; font-weight: bold;">def</span> <span style="color: #000000;">a</span> <span style="color: #7388d6;">(</span><span style="color: #000000; font-style: italic; text-decoration: underline;">nd</span>/create ndm <span style="color: #909183;">[</span>3.5<span style="color: #909183;">]</span><span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>
a
</pre>
</div>

<pre class="example">
ND: (1) cpu() float64
[3.5]
</pre>


<div class="org-src-container">
<pre class="src src-clojure"><span style="color: #707183;">(</span><span style="color: #000000; font-style: italic; text-decoration: underline;">nd</span>/get-element a<span style="color: #707183;">)</span>
</pre>
</div>

<pre class="example">
3.5
</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Kimi Ma</p>
<p class="date">Created: 2022-05-17 Tue 08:06</p>
</div>
</body>
</html>
