#+begin_src clojure
(ns clj-d2l.priliminaries
  (:require [clj-djl.ndarray :as nd]
            [clj-djl.utils :refer [pp]])
  (:import [ai.djl.ndarray.types DataType]))
#+end_src

#+RESULTS:
: nil

a helper function:

#+begin_src clojure
(defmacro pp [expr]
  `(print (str ~expr)))
#+end_src

Create a vector from in range 0 - 11:

#+begin_src clojure
(def x (nd/arange 0 12))
#+end_src

#+RESULTS:
: #'clj-d2l.priliminaries/x

#+begin_src clojure :results output
(println x)
(println (str x))
#+end_src

#+RESULTS:
: #object[ai.djl.mxnet.engine.MxNDArray 0x2cf100e5 ND: (12) cpu() int32
: [ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11]
: ]
: ND: (12) cpu() int32
: [ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11]
:


#+begin_src clojure
(nd/get-shape x)
(nd/size x)
#+end_src

#+RESULTS:
: #object[ai.djl.ndarray.types.Shape 0x79bb7ddd "(12)"]12

#+begin_src clojure :results output
(def y (nd/reshape x [3 4]))
(println (str y))
#+end_src

#+RESULTS:
: ND: (3, 4) cpu() int32
: [[ 0,  1,  2,  3],
:  [ 4,  5,  6,  7],
:  [ 8,  9, 10, 11],
: ]
:

automatically inference the rest dimention specified with =-1=:

#+begin_src clojure :results output
(def y (nd/reshape x [3 -1]))
(println (str y))
#+end_src

#+RESULTS:
: ND: (3, 4) cpu() int32
: [[ 0,  1,  2,  3],
:  [ 4,  5,  6,  7],
:  [ 8,  9, 10, 11],
: ]
:


#+begin_src clojure :results output
(print (nd/shape 2 3))
#+end_src

#+RESULTS:
: #object[ai.djl.ndarray.types.Shape 0x1da4057a (2, 3)]

#+begin_src clojure :results output
(print (str (nd/create [2 3])))
#+end_src

#+RESULTS:
: ND: (2, 3) cpu() float32
: [[ 0.00000000e+00,  0.00000000e+00,  1.35925951e-43],
:  [ 0.00000000e+00,  4.46097167e-34,  4.56949416e-41],
: ]

#+begin_src clojure :results output
(print (str (nd/zeros 2 3)))
(print (str (nd/zeros 2 3 4)))
(print (str (nd/zeros 2 2 2 2)))
(print (str (nd/zeros [2 3])))
(print (str (nd/zeros [2 3 4])))
(print (str (nd/zeros [2 2 2 2])))
#+end_src

#+RESULTS:
#+begin_example
ND: (2, 3) cpu() float32
[[0., 0., 0.],
 [0., 0., 0.],
]
ND: (2, 3, 4) cpu() float32
[[[0., 0., 0., 0.],
  [0., 0., 0., 0.],
  [0., 0., 0., 0.],
 ],
 [[0., 0., 0., 0.],
  [0., 0., 0., 0.],
  [0., 0., 0., 0.],
 ],
]
ND: (2, 2, 2, 2) cpu() float32
[[[[0., 0.],
   [0., 0.],
  ],
  [[0., 0.],
   [0., 0.],
  ],
 ],
 [[[0., 0.],
   [0., 0.],
  ],
  [[0., 0.],
   [0., 0.],
  ],
 ],
]
ND: (2, 3) cpu() float32
[[0., 0., 0.],
 [0., 0., 0.],
]
ND: (2, 3, 4) cpu() float32
[[[0., 0., 0., 0.],
  [0., 0., 0., 0.],
  [0., 0., 0., 0.],
 ],
 [[0., 0., 0., 0.],
  [0., 0., 0., 0.],
  [0., 0., 0., 0.],
 ],
]
ND: (2, 2, 2, 2) cpu() float32
[[[[0., 0.],
   [0., 0.],
  ],
  [[0., 0.],
   [0., 0.],
  ],
 ],
 [[[0., 0.],
   [0., 0.],
  ],
  [[0., 0.],
   [0., 0.],
  ],
 ],
]
#+end_example

#+begin_src clojure :results output
(print (str (nd/ones 2 3)))
(print (str (nd/ones 2 3 4)))
(print (str (nd/ones 2 2 2 2)))
(print (str (nd/ones [2 3])))
(print (str (nd/ones [2 3 4])))
(print (str (nd/ones [2 2 2 2])))
#+end_src

#+RESULTS:
#+begin_example
ND: (2, 3) cpu() float32
[[1., 1., 1.],
 [1., 1., 1.],
]
ND: (2, 3, 4) cpu() float32
[[[1., 1., 1., 1.],
  [1., 1., 1., 1.],
  [1., 1., 1., 1.],
 ],
 [[1., 1., 1., 1.],
  [1., 1., 1., 1.],
  [1., 1., 1., 1.],
 ],
]
ND: (2, 2, 2, 2) cpu() float32
[[[[1., 1.],
   [1., 1.],
  ],
  [[1., 1.],
   [1., 1.],
  ],
 ],
 [[[1., 1.],
   [1., 1.],
  ],
  [[1., 1.],
   [1., 1.],
  ],
 ],
]
ND: (2, 3) cpu() float32
[[1., 1., 1.],
 [1., 1., 1.],
]
ND: (2, 3, 4) cpu() float32
[[[1., 1., 1., 1.],
  [1., 1., 1., 1.],
  [1., 1., 1., 1.],
 ],
 [[1., 1., 1., 1.],
  [1., 1., 1., 1.],
  [1., 1., 1., 1.],
 ],
]
ND: (2, 2, 2, 2) cpu() float32
[[[[1., 1.],
   [1., 1.],
  ],
  [[1., 1.],
   [1., 1.],
  ],
 ],
 [[[1., 1.],
   [1., 1.],
  ],
  [[1., 1.],
   [1., 1.],
  ],
 ],
]
#+end_example


#+begin_src clojure :results output
(print (str (nd/random-normal 0 1 [3 4] DataType/FLOAT32)))
#+end_src

#+RESULTS:
: ND: (3, 4) cpu() float32
: [[ 2.2122,  1.1631,  0.774 ,  0.4838],
:  [ 1.0434,  0.2996,  1.1839,  0.153 ],
:  [ 1.8917, -1.1688, -1.2347,  1.5581],
: ]

#+begin_src clojure :results output
(print (str (nd/random-normal [3 4])))
#+end_src

#+RESULTS:
: ND: (3, 4) cpu() float32
: [[-1.771 , -0.5459, -0.4514, -2.3556],
:  [ 0.5794,  0.5414, -1.8561,  2.6785],
:  [-1.9769,  1.2546, -0.208 , -0.5488],
: ]

#+begin_src clojure :results output
(print (str (nd/create [2 1 4 3] [2 2])))
#+end_src

#+RESULTS:
: ND: (2, 2) cpu() float32
: [[2., 1.],
:  [4., 3.],
: ]



#+begin_src clojure :results output
;;(println (str (nd/->ndarray [[2 1 4 3] [1 2 3 4] [4 3 2 1]])))
#+end_src

#+RESULTS:

#+begin_src clojure :results output
(def x (nd/create [1 2 4 8] [2 2]))
(def y (nd/create [2 2 2 2] [2 2]))
(pp x)
(pp y)
(pp (nd/+ x y))
(pp (nd/- x y))
(pp (nd/* x y))
(pp (nd// x y))
(pp (nd/** x y))
(pp (nd/exp x))
#+end_src

#+RESULTS:
#+begin_example
ND: (2, 2) cpu() float32
[[1., 2.],
 [4., 8.],
]
ND: (2, 2) cpu() float32
[[2., 2.],
 [2., 2.],
]
ND: (2, 2) cpu() float32
[[ 3.,  4.],
 [ 6., 10.],
]
ND: (2, 2) cpu() float32
[[-1.,  0.],
 [ 2.,  6.],
]
ND: (2, 2) cpu() float32
[[ 2.,  4.],
 [ 8., 16.],
]
ND: (2, 2) cpu() float32
[[0.5, 1. ],
 [2. , 4. ],
]
ND: (2, 2) cpu() float32
[[ 1.,  4.],
 [16., 64.],
]
ND: (2, 2) cpu() float32
[[ 2.71828175e+00,  7.38905621e+00],
 [ 5.45981483e+01,  2.98095801e+03],
]
ND: (2, 2) cpu() boolean
[[false,  true],
 [false, false],
]
#+end_example

#+begin_src clojure :results output
(pp (nd/= x y))
#+end_src

#+RESULTS:
: ND: (2, 2) cpu() boolean
: [[false,  true],
:  [false, false],
: ]

#+begin_src clojure :results output
(def X (-> (nd/arange 0 12) (nd/reshape [3 4])))
;;(def Y (nd/create [2, 1, 4, 3, 1, 2, 3, 4, 4, 3, 2, 1] [3 4]))
(def Y (-> (nd/arange 0 12) (nd/reshape [3 4])))
(pp (nd/concat X Y))
(pp (nd/concat X Y :axis 0))
(pp (nd/concat X Y :axis 1))
#+end_src

#+RESULTS:
#+begin_example
ND: (6, 4) cpu() int32
[[ 0,  1,  2,  3],
 [ 4,  5,  6,  7],
 [ 8,  9, 10, 11],
 [ 0,  1,  2,  3],
 [ 4,  5,  6,  7],
 [ 8,  9, 10, 11],
]
ND: (6, 4) cpu() int32
[[ 0,  1,  2,  3],
 [ 4,  5,  6,  7],
 [ 8,  9, 10, 11],
 [ 0,  1,  2,  3],
 [ 4,  5,  6,  7],
 [ 8,  9, 10, 11],
]
ND: (3, 8) cpu() int32
[[ 0,  1,  2,  3,  0,  1,  2,  3],
 [ 4,  5,  6,  7,  4,  5,  6,  7],
 [ 8,  9, 10, 11,  8,  9, 10, 11],
]
#+end_example

#+begin_src clojure :results output
(pp (nd/= X Y))
#+end_src

#+RESULTS:
: ND: (3, 4) cpu() boolean
: [[ true,  true,  true,  true],
:  [ true,  true,  true,  true],
:  [ true,  true,  true,  true],
: ]

#+begin_src clojure :results output
(pp (nd/sum X))
#+end_src

#+RESULTS:
: ND: () cpu() int32
: 66
