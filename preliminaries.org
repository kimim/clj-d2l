#+begin_src clojure :results silent
(ns clj-d2l.priliminaries
  (:require [clj-djl.ndarray :as nd])
  (:import [ai.djl.ndarray.types DataType]))
#+end_src

a helper function:

#+begin_src clojure :exports both
(defmacro pp [expr]
  `(print (str ~expr)))
#+end_src

#+RESULTS:
: #'clj-d2l.priliminaries/pp

Create a vector from in range 0 - 11:

#+begin_src clojure :exports both
(def ndm (nd/new-base-manager))
#+end_src

#+RESULTS:
: #'clj-d2l.priliminaries/ndm

#+begin_src clojure :exports both
(def x (nd/arange ndm 0 12))
#+end_src

#+RESULTS:
: #'clj-d2l.priliminaries/x

#+begin_src clojure :results output :exports both
(println x)
(println (str x))
#+end_src

#+RESULTS:
: #object[ai.djl.mxnet.engine.MxNDArray 0x1215ea33 ND: (12) cpu() int32
: [ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11]
: ]
: ND: (12) cpu() int32
: [ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11]
:


#+begin_src clojure :exports both
(nd/get-shape x)
(nd/size x)
#+end_src

#+RESULTS:
: #object[ai.djl.ndarray.types.Shape 0x7cfd9ada "(12)"]12

#+begin_src clojure :results output :exports both
(def y (nd/reshape x [3 4]))
(println (str y))
#+end_src

#+RESULTS:
: ND: (3, 4) cpu() int32
: [[ 0,  1,  2,  3],
:  [ 4,  5,  6,  7],
:  [ 8,  9, 10, 11],
: ]
:

automatically inference the rest dimention specified with =-1=:

#+begin_src clojure :results output :exports both
(def y (nd/reshape x [3 -1]))
(println (str y))
#+end_src

#+RESULTS:
: ND: (3, 4) cpu() int32
: [[ 0,  1,  2,  3],
:  [ 4,  5,  6,  7],
:  [ 8,  9, 10, 11],
: ]
:


#+begin_src clojure :results output :exports both
(print (nd/shape 2 3))
#+end_src

#+RESULTS:
: #object[ai.djl.ndarray.types.Shape 0x2c464cb7 (2, 3)]

#+begin_src clojure :results output :exports both
(print (str (nd/create ndm (int-array [2 3]))))
#+end_src

#+RESULTS:
: ND: (2) cpu() int32
: [ 2,  3]

#+begin_src clojure :results output :exports both
(print (str (nd/zeros ndm 2 3)))
(print (str (nd/zeros ndm 2 3 4)))
(print (str (nd/zeros ndm 2 2 2 2)))
(print (str (nd/zeros ndm [2 3])))
(print (str (nd/zeros ndm [2 3 4])))
(print (str (nd/zeros ndm [2 2 2 2])))
#+end_src

#+RESULTS:
#+begin_example
ND: (2, 3) cpu() float32
[[0., 0., 0.],
 [0., 0., 0.],
]
ND: (2, 3, 4) cpu() float32
[[[0., 0., 0., 0.],
  [0., 0., 0., 0.],
  [0., 0., 0., 0.],
 ],
 [[0., 0., 0., 0.],
  [0., 0., 0., 0.],
  [0., 0., 0., 0.],
 ],
]
ND: (2, 2, 2, 2) cpu() float32
[[[[0., 0.],
   [0., 0.],
  ],
  [[0., 0.],
   [0., 0.],
  ],
 ],
 [[[0., 0.],
   [0., 0.],
  ],
  [[0., 0.],
   [0., 0.],
  ],
 ],
]
ND: (2, 3) cpu() float32
[[0., 0., 0.],
 [0., 0., 0.],
]
ND: (2, 3, 4) cpu() float32
[[[0., 0., 0., 0.],
  [0., 0., 0., 0.],
  [0., 0., 0., 0.],
 ],
 [[0., 0., 0., 0.],
  [0., 0., 0., 0.],
  [0., 0., 0., 0.],
 ],
]
ND: (2, 2, 2, 2) cpu() float32
[[[[0., 0.],
   [0., 0.],
  ],
  [[0., 0.],
   [0., 0.],
  ],
 ],
 [[[0., 0.],
   [0., 0.],
  ],
  [[0., 0.],
   [0., 0.],
  ],
 ],
]
#+end_example

#+begin_src clojure :results output :exports both
(print (str (nd/ones ndm 2 3)))
(print (str (nd/ones ndm 2 3 4)))
(print (str (nd/ones ndm 2 2 2 2)))
(print (str (nd/ones ndm [2 3])))
(print (str (nd/ones ndm [2 3 4])))
(print (str (nd/ones ndm [2 2 2 2])))
#+end_src

#+RESULTS:
#+begin_example
ND: (2, 3) cpu() float32
[[1., 1., 1.],
 [1., 1., 1.],
]
ND: (2, 3, 4) cpu() float32
[[[1., 1., 1., 1.],
  [1., 1., 1., 1.],
  [1., 1., 1., 1.],
 ],
 [[1., 1., 1., 1.],
  [1., 1., 1., 1.],
  [1., 1., 1., 1.],
 ],
]
ND: (2, 2, 2, 2) cpu() float32
[[[[1., 1.],
   [1., 1.],
  ],
  [[1., 1.],
   [1., 1.],
  ],
 ],
 [[[1., 1.],
   [1., 1.],
  ],
  [[1., 1.],
   [1., 1.],
  ],
 ],
]
ND: (2, 3) cpu() float32
[[1., 1., 1.],
 [1., 1., 1.],
]
ND: (2, 3, 4) cpu() float32
[[[1., 1., 1., 1.],
  [1., 1., 1., 1.],
  [1., 1., 1., 1.],
 ],
 [[1., 1., 1., 1.],
  [1., 1., 1., 1.],
  [1., 1., 1., 1.],
 ],
]
ND: (2, 2, 2, 2) cpu() float32
[[[[1., 1.],
   [1., 1.],
  ],
  [[1., 1.],
   [1., 1.],
  ],
 ],
 [[[1., 1.],
   [1., 1.],
  ],
  [[1., 1.],
   [1., 1.],
  ],
 ],
]
#+end_example


#+begin_src clojure :results output :exports both
(print (str (nd/random-normal 0 1 [3 4] DataType/FLOAT32)))
#+end_src

#+RESULTS:
: ND: (3, 4) cpu() float32
: [[ 2.2122,  1.1631,  0.774 ,  0.4838],
:  [ 1.0434,  0.2996,  1.1839,  0.153 ],
:  [ 1.8917, -1.1688, -1.2347,  1.5581],
: ]

#+begin_src clojure :results output :exports both
(print (str (nd/random-normal [3 4])))
#+end_src

#+RESULTS:
: ND: (3, 4) cpu() float32
: [[ 0.2444, -0.6811, -0.0372, -0.1353],
:  [-0.4877,  0.3772, -0.0226,  0.4102],
:  [ 0.5746,  0.5713,  1.4661, -2.758 ],
: ]

#+begin_src clojure :results output :exports both
(print (str (nd/create ndm (int-array [2 1 4 3]) (nd/shape [2 2]))))
#+end_src

#+RESULTS:
: ND: (2, 2) cpu() int32
: [[ 2,  1],
:  [ 4,  3],
: ]

#+begin_src clojure :results output :exports both
;;(println (str (nd/->ndarray [[2 1 4 3] [1 2 3 4] [4 3 2 1]])))
#+end_src

#+RESULTS:

#+begin_src clojure :results output :exports both
(def x (nd/create ndm (int-array [1 2 4 8]) (nd/shape [2 2])))
(def y (nd/create ndm (int-array [2 2 2 2]) (nd/shape [2 2])))
(pp x)
(pp y)
(pp (nd/+ x y))
(pp (nd/- x y))
(pp (nd/* x y))
(pp (nd// x y))
(pp (nd/** x y))
(pp (nd/exp x))
#+end_src


#+RESULTS:
#+begin_example
ND: (2, 2) cpu() int32
[[ 1,  2],
 [ 4,  8],
]
ND: (2, 2) cpu() int32
[[ 2,  2],
 [ 2,  2],
]
ND: (2, 2) cpu() int32
[[ 3,  4],
 [ 6, 10],
]
ND: (2, 2) cpu() int32
[[-1,  0],
 [ 2,  6],
]
ND: (2, 2) cpu() int32
[[ 2,  4],
 [ 8, 16],
]
ND: (2, 2) cpu() float32
[[0.5, 1. ],
 [2. , 4. ],
]
ND: (2, 2) cpu() int32
[[ 1,  4],
 [16, 64],
]
ND: (2, 2) cpu() int32
[[   2,    7],
 [  54, 2980],
]
#+end_example

#+begin_src clojure :results output :exports both
(pp (nd/= x y))
#+end_src

#+RESULTS:
: ND: (2, 2) cpu() boolean
: [[false,  true],
:  [false, false],
: ]

#+begin_src clojure :results output :exports both
(def X (-> (nd/arange ndm 0 12) (nd/reshape [3 4])))
(def Y (nd/create ndm (int-array [2, 1, 4, 3, 1, 2, 3, 4, 4, 3, 2, 1]) (nd/shape [3 4])))
(pp (nd/concat X Y))
(pp (nd/concat X Y :axis 0))
(pp (nd/concat X Y :axis 1))
#+end_src

#+RESULTS:
#+begin_example
ND: (6, 4) cpu() int32
[[ 0,  1,  2,  3],
 [ 4,  5,  6,  7],
 [ 8,  9, 10, 11],
 [ 2,  1,  4,  3],
 [ 1,  2,  3,  4],
 [ 4,  3,  2,  1],
]
ND: (6, 4) cpu() int32
[[ 0,  1,  2,  3],
 [ 4,  5,  6,  7],
 [ 8,  9, 10, 11],
 [ 2,  1,  4,  3],
 [ 1,  2,  3,  4],
 [ 4,  3,  2,  1],
]
ND: (3, 8) cpu() int32
[[ 0,  1,  2,  3,  2,  1,  4,  3],
 [ 4,  5,  6,  7,  1,  2,  3,  4],
 [ 8,  9, 10, 11,  4,  3,  2,  1],
]
#+end_example

#+begin_src clojure :results output :exports both
(pp (nd/= X Y))
#+end_src

#+RESULTS:
: ND: (3, 4) cpu() boolean
: [[false,  true, false,  true],
:  [false, false, false, false],
:  [false, false, false, false],
: ]

#+begin_src clojure :results output :exports both
(pp (nd/sum X))
#+end_src

#+RESULTS:
: ND: () cpu() int32
: 66
